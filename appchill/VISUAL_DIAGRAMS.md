# 🎨 ВИЗУАЛЬНЫЕ СХЕМЫ И ДИАГРАММЫ

## Проблема vs Решение

### ❌ ТЕКУЩЕЕ (НЕПРАВИЛЬНОЕ)

```
Socket подключается
        ↓
emit('authenticate_socket')  ← Аутентификация начинается
        ↓
emit('join_group_room')      ← ❌ НО СИНХРОННО! Может быть до окончания auth
        ↓
registerHandler              ← Может быть userId ещё не установлен
        ↓
❌ Socket не в комнате, userId не установлен, события не приходят!
```

### ✅ ПРАВИЛЬНОЕ (ИСПРАВЛЕННОЕ)

```
Socket подключается
        ↓
emit('authenticate_socket')  ← Аутентификация начинается
        ↓
⏰ setTimeout(100ms)          ← Ждём окончания аутентификации
        ↓
emit('join_group_room')      ← ✅ Теперь userId установлен!
        ↓
registerHandler              ← ✅ Socket уже в комнате
        ↓
✅ Socket в комнате group_123, eventos приходят!
```

---

## Поток сообщения (правильный)

```
╔════════════════════════════════════════════════════════════╗
║ CLIENT USER A - Отправляет сообщение в группу 123        ║
╚════════════════════════════════════════════════════════════╝
                            ↓
                  POST /api/groups/123/messages
                            ↓
╔════════════════════════════════════════════════════════════╗
║ SERVER - Обрабатывает                                      ║
║ 1. Вставляет сообщение в БД                               ║
║ 2. messageData = { group_id: 123, message: "...", ... }    ║
║ 3. io.to('group_123').emit('new_group_message', data)     ║
╚════════════════════════════════════════════════════════════╝
                            ↓
        ┌───────────────────┴───────────────────┐
        ↓                                       ↓
   CLIENT USER A             CLIENT USER B (в group_123)
   (в group_123)             
        ↓                                       ↓
   sharedSocket.on           sharedSocket.on
   ('new_group_message')     ('new_group_message')
        ↓                                       ↓
   handleNewMessage()        handleNewMessage()
   проверка:                 проверка:
   msg.group_id === 123 ✓    msg.group_id === 123 ✓
        ↓                                       ↓
   Добавляет в список        Добавляет в список
   и показывает!             и показывает!
        ↓                                       ↓
   ✅ User A видит свое      ✅ User B видит
      сообщение                 сообщение User A
      мгновенно!                мгновенно!
```

---

## Проверка read status (галочки)

```
╔════════════════════════════════════════════════════════════╗
║ CLIENT USER B - Читает сообщение User A                   ║
╚════════════════════════════════════════════════════════════╝
                            ↓
              emit('mark_message_read', {msg_id: 456})
                            ↓
╔════════════════════════════════════════════════════════════╗
║ SERVER - Обрабатывает mark_message_read                   ║
║ 1. INSERT into group_message_read_status                  ║
║ 2. SELECT всех читателей                                  ║
║ 3. io.to('group_123').emit('message_read_status_updated', │
║    {reader_count: 2, read_by: [B_id, A_id], ...})        │
╚════════════════════════════════════════════════════════════╝
                            ↓
        ┌───────────────────┴───────────────────┐
        ↓                                       ↓
   CLIENT USER A             CLIENT USER B
   (отправитель)             (читатель)
        ↓                                       ↓
   socket.on                 socket.on
   ('msg_read_status')       ('msg_read_status')
        ↓                                       ↓
   handleMessageRead...      handleMessageRead...
        ↓                                       ↓
   Обновляет сообщение:      Обновляет сообщение:
   reader_count = 2          reader_count = 2
   Показывает ✓✓ (2)         Показывает ✓✓ (2)
        ↓                                       ↓
   ✅ USER A видит           ✅ USER B видит
      что сообщение             что сообщение
      прочитано (✓✓)            прочитано (✓✓)
```

---

## Регистрация обработчиков (правильная)

```
❌ НЕПРАВИЛЬНО (условная регистрация):
┌────────────────────────────────────────┐
│ if (isGroup) {                         │
│   registerHandler(                     │
│     'new_group_message',               │
│     handleNewMessage                   │
│   );                                   │
│ } else {                               │
│   registerHandler(                     │
│     'new_message',                     │
│     handleNewMessage                   │
│   );                                   │
│ }                                      │
│                                        │
│ ❌ Проблема: Если это групповой чат,  │
│    то 'new_message' не слушается!     │
│    Если переключиться на личный -      │
│    старая регистрация 'new_group' ещё  │
│    слушается!                         │
└────────────────────────────────────────┘


✅ ПРАВИЛЬНО (регистрируем ОБА):
┌────────────────────────────────────────┐
│ // Регистрируем оба обработчика       │
│ registerHandler(                       │
│   'new_group_message',                 │
│   handleNewMessage                     │
│ );                                     │
│                                        │
│ registerHandler(                       │
│   'new_message',                       │
│   handleNewMessage                     │
│ );                                     │
│                                        │
│ // Оба слушаются одновременно!        │
│ // handleNewMessage сам определяет    │
│ // какой это тип сообщения            │
│                                        │
│ ✅ Правильно! Работает для обоих      │
│    типов чатов                        │
└────────────────────────────────────────┘
```

---

## Проверка типа сообщения (правильная)

```
Получено сообщение: {
  id: 456,
  group_id: 123,        ← КЛЮЧЕВОЕ ПОЛЕ!
  sender_id: 2,
  message: "Привет!"
}

┌─────────────────────────────────────────────┐
│ if (isGroup) {                              │
│   // Это групповой чат?                    │
│   isForThisChat = message.group_id === 123 │
│   //            проверяем group_id!       │
│ } else {                                    │
│   // Это личный чат?                       │
│   isForThisChat = (                         │
│     (msg.sender_id === 2 &&                 │
│      msg.receiver_id === 1) ||              │
│     (msg.sender_id === 1 &&                 │
│      msg.receiver_id === 2)                 │
│   )                                         │
│   //  проверяем sender/receiver            │
│ }                                           │
│                                             │
│ if (isForThisChat) {                        │
│   // ДОБАВЛЯЕМ сообщение в список         │
│   setMessages([...prev, message])          │
│ }                                           │
└─────────────────────────────────────────────┘
```

---

## Архитектура комнат Socket.io

```
SERVER (Socket.io)
│
├─ Комнаты для групп:
│  ├─ group_1    (участники: socket_A, socket_B, socket_C)
│  ├─ group_2    (участники: socket_D, socket_E)
│  └─ group_123  (участники: socket_X, socket_Y) ← НАША ГРУППА
│
├─ Комнаты для личных:
│  ├─ user_1     (чат User1↔User2)
│  ├─ user_2     (чат User1↔User2)
│  └─ user_123   (чат User123↔User124)
│
└─ Системные события:
   └─ authenticate_socket, user_status и т.д.


Когда отправляется сообщение в группу 123:
  io.to('group_123').emit('new_group_message', data)
  ↓
  Все сокеты в комнате group_123 получают событие:
  socket_X ← ✓ ПОЛУЧИТ
  socket_Y ← ✓ ПОЛУЧИТ
  socket_Z ← ❌ НЕ ПОЛУЧИТ (не в комнате group_123)
```

---

## Таймлайн подключения (с числами)

```
Время    Событие                          Статус Socket
────────────────────────────────────────────────────────
0ms      1. Открываем чат               userId = null
         2. WebSocket connect            ✅ Подключен

50ms     3. emit('authenticate')         userId = в процессе
         
100ms    4. SERVER получает auth         userId = установлен! ✓

105ms    5. setTimeout() завершается     userId = ✓

110ms    6. emit('join_group_room')      ✅ userId = ✓
         7. SERVER получает join         Socket присоединён
                                         к group_123 ✓

120ms    8. registerHandler('new_...')   ✅ Обработчик готов!

130ms    9. USER может отправлять мсг   ✅ ВСЁ РАБОТАЕТ!

Если убрать setTimeout (ошибка):
50ms     emit('authenticate')            userId = в процессе
51ms     emit('join_group_room')         ❌ userId ещё null!
52ms     SERVER отклоняет join           ❌ ОШИБКА!
```

---

## Состояния сообщения

```
Создание → Отправка → Доставка → Чтение

ЛИЧНОЕ СООБЩЕНИЕ:
Сообщение создано
    ↓
  is_read = 0 (false)
    ↓
Отправлено Receiver
    ↓
  is_read = 1 (true)
    ↓
Отправитель видит: ✓ (одна галочка) если прочитано
                   ✓  (одна галочка) если не прочитано

ГРУППОВОЕ СООБЩЕНИЕ:
Сообщение создано
    ↓
  reader_count = 1 (сам автор)
    ↓
Отправлено группе
    ↓
  reader_count = 2 (автор + Member2)
  reader_count = 3 (автор + Member2 + Member3)
    ↓
Отправитель видит: ✓✓ (2) если 2 человека прочитали
                   ✓✓ (3) если 3 человека прочитали
```

---

## Отладка - Что смотреть в консоли

```
🔴 ПЛОХИЕ ЛОГИ - Значит есть проблема:
─────────────────────────────────────
❌ Нет логов "✅ Подключено к WebSocket"
  → Socket не подключается вообще
  
❌ Нет логов "🔐 Socket authenticated"
  → Аутентификация не прошла
  
❌ Нет логов "🔴 ПРИСОЕДИНЯЮСЬ К ГРУППОВОЙ КОМНАТЕ"
  → join_group_room не вызывается
  
❌ Нет логов "🔴 [DIRECT ON] new_group_message получено"
  → События не приходят от сервера


🟢 ХОРОШИЕ ЛОГИ - Всё правильно:
──────────────────────────────
✅ ✅ Подключено к WebSocket
✅ 🔐 Socket authenticated with user_id: 123
✅ 🔴 ПРИСОЕДИНЯЮСЬ К ГРУППОВОЙ КОМНАТЕ
✅ ✅ Эмит 'join_group_room' отправлен на сервер
✅ 🔴 [DIRECT ON] new_group_message получено: {...}
✅ 🔔 [ChatScreen] Получено сообщение: {...}
✅ ✅ Добавляем сообщение в список
```

---

## Быстрая диагностика (5 вопросов)

```
1. ВИдишь ли ты логи подключения к Socket?
   ├─ ДА  → Переходи к вопросу 2
   └─ НЕТ → Проверь что Socket инициализируется

2. Видишь ли логи аутентификации?
   ├─ ДА  → Переходи к вопросу 3
   └─ НЕТ → Проверь authenticate_socket в коде

3. Видишь ли логи присоединения к группе?
   ├─ ДА  → Переходи к вопросу 4
   └─ НЕТ → Проверь setTimeout и join_group_room

4. Видишь ли логи получения сообщения?
   ├─ ДА  → Переходи к вопросу 5
   └─ НЕТ → Проверь registerHandler и Direct Listeners

5. Видишь ли логи добавления в список?
   ├─ ДА  → ✅ ВСЁ РАБОТАЕТ!
   └─ НЕТ → Проверь handleNewMessage логику
```

---

## Примеры реальных логов

### ✅ ПРАВИЛЬНО (Всё работает)

```
✅ Подключено к WebSocket
🔐 Socket authenticated with user_id: 1
🔴 ПРИСОЕДИНЯЮСЬ К ГРУППОВОЙ КОМНАТЕ
   group_id: 123
   current_user_id: 1
============================================================
✅ Эмит 'join_group_room' отправлен на сервер

🚀 ДОБАВЛЯЮ DIRECT LISTENERS ДЛЯ ГРУППЫ 123
============================================================
✅ Добавлен sharedSocket.on('new_group_message')
✅ Добавлен sharedSocket.on('message_read_status_updated')

User отправляет сообщение...

🔴 [DIRECT ON] new_group_message получено:
   Message ID: 456
   Group ID: 123
   Sender: 2
   Current user: 1
   Current group: 123
   Match: true ✓

🔔 [ChatScreen] Получено сообщение: {...}
   От: 2 | Кому: undefined
   isGroup=true, user.id=123, message.group_id=123
   Group message check: 123 === 123? true ✓
   ✅ Добавляем сообщение в список

✅ Сообщение добавлено в список. Всего сообщений: 15
📍 Скроллю вниз
```

### ❌ НЕПРАВИЛЬНО (Проблема)

```
✅ Подключено к WebSocket
🔐 Socket authenticated with user_id: 1
❌ БЕЗ ЛОГОВ О ПРИСОЕДИНЕНИИ К ГРУППЕ!
❌ БЕЗ ЛОГОВ О DIRECT LISTENERS!

User отправляет сообщение...

❌ БЕЗ ЛОГОВ О ПОЛУЧЕНИИ new_group_message!
❌ БЕЗ ЛОГОВ О ДОБАВЛЕНИИ СООБЩЕНИЯ!

User видит что-то странное...
```

---

## Конец схем 📊

Используй эти диаграммы для понимания того как всё должно работать!
